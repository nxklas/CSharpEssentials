using static CSharpEssentials.Helpers.PathHelper;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Text;
using System.Runtime.CompilerServices;

namespace CSharpEssentials.Config
{
    /// <summary>
    /// Represents the base class for configs that write / read in the file-system
    /// </summary>
    public abstract class DirectoryConfiguration : IConfigurable
    {
        #region Fields
        /// <summary>
        /// Represents the name of the config file
        /// </summary>
        protected const string FileName = "config.ini";
        private readonly string _appName;
        #endregion

        #region Constructors
        /// <summary>
        /// Initializes a new instance of <see cref="DirectoryConfiguration"/> class
        /// </summary>
        /// <param name="appName">The name of the application (the folder name where config is in should use the it)</param>
        protected DirectoryConfiguration(string appName)
        {
            _appName = appName;
            CreateFileIfDoesntExist();
        }
        #endregion

        #region Properties
        /// <summary>
        /// Represents the path to the config file
        /// </summary>
        protected abstract string Path { get; }
        /// <summary>
        /// Represents the name of the application
        /// </summary>
        protected string AppName => _appName;
        /// <summary>
        /// Represents the phrase inserted at the beginning of the config file.
        /// </summary>
        protected virtual string DoNotModifyPhrase =>
            $"# This file has been auto-generated by {nameof(CSharpEssentials)}' configuration system for the {_appName} app." +
            $"{Environment.NewLine}# Please do not modify!{Environment.NewLine}{Environment.NewLine}";
        #endregion

        #region Public methods
        public virtual ImmutableArray<KeyValuePair<string, string?>> Read(params string[] keys)
        {
            CreateFileIfDoesntExist();

            var values = ImmutableArray.CreateBuilder<KeyValuePair<string, string?>>();
            var text = File.ReadAllText(Path);
            var lines = text.Split(Environment.NewLine);

            foreach (var key in keys)
            {
                var found = false;

                foreach (var line in lines)
                {
                    if (line.StartsWith('#'))
                        continue;

                    var keyValue = line.Split('=');

                    if (keyValue[0].Trim() == key)
                    {
                        var value = keyValue[1].Trim();

                        if (value == string.Empty)
                            continue;

                        found = true;
                        values.Add(new KeyValuePair<string, string?>(key, value));
                        break;
                    }
                }

                if (!found)
                    values.Add(new KeyValuePair<string, string?>(key, null));
            }

            return values.ToImmutable();
        }

        public virtual string? Read(string key)
        {
            CreateFileIfDoesntExist();

            var text = File.ReadAllText(Path);
            var lines = text.Split(Environment.NewLine);

            foreach (var line in lines)
            {
                if (line.StartsWith('#'))
                    continue;

                var keyValue = line.Split('=');

                if (keyValue[0].Trim() == key)
                {
                    var value = keyValue[1].Trim();

                    if (value == string.Empty)
                        break;

                    return value;
                }
            }

            return null;
        }

        public virtual void Write(params KeyValuePair<string, string>[] keyValues)
        {
            CreateFileIfDoesntExist();

            var text = File.ReadAllText(Path);
            var builder = new StringBuilder(text);

            foreach (var keyValue in keyValues)
                if (!ChangeValue(builder, keyValue.Key, keyValue.Value))
                    builder.AppendLine($"{keyValue.Key} = {keyValue.Value}");

            WriteStringBuilder(builder);
        }

        public virtual void Write(string key, string value)
        {
            CreateFileIfDoesntExist();

            var text = File.ReadAllText(Path);
            var builder = new StringBuilder(text);

            if (!ChangeValue(builder, key, value))
                builder.AppendLine($"{key} = {value}");

            WriteStringBuilder(builder);
        }

        public virtual bool Remove([DisallowNull] string key)
        {
            CreateFileIfDoesntExist();

            var found = false;
            var builder = new StringBuilder();
            var text = File.ReadAllText(Path);
            var lines = text.Split(Environment.NewLine);

            foreach (var line in lines)
            {
                if (line.StartsWith('#') || line == string.Empty)
                    continue;

                var keyValue = line.Split('=');

                if (keyValue[0].Trim() == key)
                {
                    found = true;
                    continue;
                }

                builder.AppendLine(line);
            }

            return found;
        }
        #endregion

        /// <summary>
        /// Writes the content of <paramref name="builder"/> to the file addressed with <see cref="Path"/>.
        /// <br>Inserts <see cref="DoNotModifyPhrase"/> if <paramref name="builder"/> does not start with it.</br>
        /// </summary>
        /// <param name="builder">The <see cref="StringBuilder"/> instance to write.</param>
        protected void WriteStringBuilder(StringBuilder builder)
        {
            if (!builder.ToString().StartsWith(DoNotModifyPhrase))
                builder.Insert(0, DoNotModifyPhrase);

            if (!File.Exists(Path))
                File.Create(Path);

            File.WriteAllText(Path, builder.ToString());
        }

        /// <summary>
        /// Assuming that <paramref name="builder"/> contains key value pairs ({key} = {value}) splitted by <see cref="Environment.NewLine"/>,
        /// it updates the line where <paramref name="key"/> was found by the specified value.
        /// </summary>
        /// <param name="builder">The builder to update.</param>
        /// <param name="key">The key associated with <paramref name="newValue"/>.</param>
        /// <param name="newValue">The value to update.</param>
        /// <returns><see langword="true"/> if the updated was performed successfully; otherwise (key was not found), <see langword="false"/>.</returns>
        protected static bool ChangeValue(StringBuilder builder, string key, string newValue)
        {
            var found = false;
            var lines = builder.ToString().Split(Environment.NewLine);

            builder.Clear();

            for (var i = 0; i < lines.Length; i++)
            {
                var line = lines[i];

                if (line.StartsWith('#') || line == string.Empty)
                    continue;

                var keyValue = line.Split('=');

                if (keyValue[0].Trim() == key)
                {
                    var value = keyValue[1].Trim();

                    if (value == string.Empty)
                        continue;

                    found = true;
                    line = $"{key} = {newValue}";
                }

                builder.AppendLine(line);
            }

            //foreach (var line in lines)
            //{
            //    if (!line.StartsWith('#'))
            //    {
            //        var keyValue = line.Split('=');

            //        if (keyValue[0].Trim() == key)
            //        {
            //            found = true;
            //            break;
            //        }
            //    }

            //    i++;
            //}

            //if (found)
            //{
            //    lines[i] = $"{key} = {newValue}";
            //    builder.Clear();

            //    foreach (var line in lines)
            //    {
            //        if (line.StartsWith('#'))
            //            continue;

            //        var l = line.Trim();

            //        if (l.Trim() != string.Empty)
            //            builder.AppendLine(l);
            //    }
            //}

            return found;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected void CreateFileIfDoesntExist()
        {
            var path = Path;

            if (!File.Exists(path))
            {
                var dir = RemoveFileName(path);

                if (!Directory.Exists(dir))
                    Directory.CreateDirectory(dir);

                File.Create(path);
            }
        }
    }
}